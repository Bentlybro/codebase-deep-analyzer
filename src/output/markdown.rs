use anyhow::Result;
use std::collections::HashMap;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;

use crate::core::analyzer::GapKind;
use crate::core::{Analysis, CrossReference};

/// Generate README and gaps files (modules may already exist from streaming)
pub fn generate(analysis: &Analysis, crossref: &CrossReference, output_path: &Path) -> Result<()> {
    // Ensure modules directory exists
    let modules_dir = output_path.join("modules");
    fs::create_dir_all(&modules_dir)?;

    // Generate README.md
    let index_path = output_path.join("README.md");
    let mut index = File::create(&index_path)?;

    writeln!(index, "# Codebase Analysis\n")?;
    writeln!(
        index,
        "Generated by [CDA](https://github.com/Bentlybro/codebase-deep-analyzer)\n"
    )?;

    // Architecture overview (if LLM-generated)
    if let Some(overview) = &crossref.architecture_overview {
        writeln!(index, "## Architecture Overview\n")?;
        writeln!(index, "{}\n", overview)?;
    }

    // Statistics
    writeln!(index, "## Overview\n")?;
    writeln!(index, "| Metric | Count |")?;
    writeln!(index, "|--------|-------|")?;
    writeln!(index, "| Modules analyzed | {} |", analysis.modules.len())?;
    writeln!(index, "| Total exports | {} |", analysis.total_exports())?;
    writeln!(
        index,
        "| External dependencies | {} |",
        crossref.external_deps.len()
    )?;
    writeln!(index, "| Potential gaps | {} |", crossref.gaps.len())?;

    let llm_count = analysis.modules.iter().filter(|m| m.has_deep_analysis).count();
    if llm_count > 0 {
        writeln!(index, "| LLM-analyzed modules | {} |", llm_count)?;
    }

    // External dependencies
    if !crossref.external_deps.is_empty() {
        writeln!(index, "\n## External Dependencies\n")?;
        for dep in &crossref.external_deps {
            writeln!(index, "- `{}`", dep)?;
        }
    }

    // Group modules by directory
    let mut modules_by_dir: HashMap<String, Vec<&crate::core::analyzer::ModuleAnalysis>> =
        HashMap::new();
    for module in &analysis.modules {
        let dir = Path::new(&module.path)
            .parent()
            .and_then(|p| p.file_name())
            .and_then(|s| s.to_str())
            .unwrap_or("root")
            .to_string();
        modules_by_dir.entry(dir).or_default().push(module);
    }

    // Modules section
    writeln!(index, "\n## Modules\n")?;
    let mut dirs: Vec<_> = modules_by_dir.keys().collect();
    dirs.sort();

    for dir in dirs {
        let modules = &modules_by_dir[dir];
        writeln!(index, "### {}/\n", dir)?;

        for module in modules {
            let module_name = Path::new(&module.path)
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("unknown");

            let safe_name = module.path.replace(['/', '.'], "_");
            let export_count = module.exports.len();

            // Check if module file exists (from streaming)
            let module_file = modules_dir.join(format!("{}.md", safe_name));
            if module_file.exists() || export_count > 0 {
                writeln!(
                    index,
                    "- [{}](modules/{}.md) — {}",
                    module_name, safe_name, module.summary
                )?;
            } else {
                writeln!(index, "- {} — {}", module_name, module.summary)?;
            }
        }
        writeln!(index)?;
    }

    // Gaps section
    if !crossref.gaps.is_empty() {
        writeln!(index, "## Potential Gaps\n")?;
        writeln!(index, "See [gaps.md](gaps.md) for details.\n")?;
    }

    // Write module files only if they don't exist (for static-only mode)
    for module in &analysis.modules {
        if module.exports.is_empty() && !module.has_deep_analysis {
            continue;
        }

        let safe_name = module.path.replace(['/', '.'], "_");
        let module_path = modules_dir.join(format!("{}.md", safe_name));

        // Skip if already written by streaming
        if module_path.exists() {
            continue;
        }

        let mut file = File::create(&module_path)?;

        let module_name = Path::new(&module.path)
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown");

        writeln!(file, "# {}\n", module_name)?;
        writeln!(file, "**Path:** `{}`\n", module.path)?;
        writeln!(file, "**Language:** {:?}\n", module.language)?;
        writeln!(file, "{}\n", module.summary)?;

        // Exports table
        if !module.exports.is_empty() {
            writeln!(file, "## Exports\n")?;
            writeln!(file, "| Name | Kind | Line | Description |")?;
            writeln!(file, "|------|------|------|-------------|")?;

            for export in &module.exports {
                let desc = if export.description.len() > 50 {
                    format!("{}...", &export.description[..47])
                } else {
                    export.description.clone()
                };
                writeln!(
                    file,
                    "| `{}` | {} | {} | {} |",
                    export.name, export.kind, export.line_number, desc
                )?;
            }

            writeln!(file, "\n## Export Details\n")?;

            for export in &module.exports {
                writeln!(file, "### `{}`\n", export.name)?;
                writeln!(
                    file,
                    "**Kind:** {} | **Line:** {}\n",
                    export.kind, export.line_number
                )?;

                if let Some(sig) = &export.signature {
                    writeln!(file, "```rust\n{}\n```\n", sig)?;
                }

                if !export.description.is_empty() {
                    writeln!(file, "{}\n", export.description)?;
                }
            }
        }

        // Imports
        if !module.imports.is_empty() {
            writeln!(file, "## Dependencies\n")?;

            let external: Vec<_> = module.imports.iter().filter(|i| i.is_external).collect();
            let internal: Vec<_> = module.imports.iter().filter(|i| !i.is_external).collect();

            if !external.is_empty() {
                writeln!(file, "### External\n")?;
                for import in external {
                    writeln!(file, "- `{}`", import.source)?;
                }
                writeln!(file)?;
            }

            if !internal.is_empty() {
                writeln!(file, "### Internal\n")?;
                for import in internal {
                    writeln!(file, "- `{}`", import.source)?;
                }
            }
        }
    }

    // Generate gaps.md if there are gaps
    if !crossref.gaps.is_empty() {
        let gaps_path = output_path.join("gaps.md");
        let mut gaps = File::create(&gaps_path)?;

        writeln!(gaps, "# Potential Gaps\n")?;
        writeln!(gaps, "Issues identified during analysis:\n")?;

        // Group by kind
        let mut by_kind: HashMap<&str, Vec<&crate::core::analyzer::Gap>> = HashMap::new();
        for gap in &crossref.gaps {
            let kind_str = match gap.kind {
                GapKind::UnusedExport => "Unused Exports",
                GapKind::MissingDocumentation => "Missing Documentation",
                GapKind::DeadCode => "Dead Code",
                GapKind::UntestedFunction => "Untested Functions",
                GapKind::UndocumentedCommand => "Undocumented Commands",
            };
            by_kind.entry(kind_str).or_default().push(gap);
        }

        for (kind, gaps_list) in by_kind {
            writeln!(gaps, "## {}\n", kind)?;
            for gap in gaps_list {
                writeln!(gaps, "- {}", gap.description)?;
                if let Some(loc) = &gap.location {
                    writeln!(gaps, "  - Location: `{}`", loc)?;
                }
            }
            writeln!(gaps)?;
        }
    }

    Ok(())
}
