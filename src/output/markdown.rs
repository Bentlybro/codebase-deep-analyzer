use anyhow::Result;
use std::fs;
use std::io::Write;
use std::path::Path;

use crate::core::{Analysis, CrossReference};
use crate::core::analyzer::ExportKind;

pub fn generate(analysis: &Analysis, crossref: &CrossReference, output_path: &Path) -> Result<()> {
    // Generate index.md
    let index_path = output_path.join("index.md");
    let mut index = fs::File::create(&index_path)?;
    
    writeln!(index, "# Codebase Analysis\n")?;
    writeln!(index, "Generated by [CDA](https://github.com/Bentlybro/codebase-deep-analyzer)\n")?;
    writeln!(index, "## Modules\n")?;
    
    for module in &analysis.modules {
        let module_name = Path::new(&module.path)
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown");
        
        writeln!(index, "- [{}](modules/{}.md) - {} exports", 
            module_name, 
            module_name,
            module.exports.len()
        )?;
    }
    
    writeln!(index, "\n## Statistics\n")?;
    writeln!(index, "- **Total modules:** {}", analysis.modules.len())?;
    writeln!(index, "- **Total exports:** {}", analysis.total_exports())?;
    writeln!(index, "- **Dependencies mapped:** {}", crossref.dependencies.len())?;
    writeln!(index, "- **Potential gaps:** {}", crossref.gaps.len())?;
    
    // Generate modules directory
    let modules_dir = output_path.join("modules");
    fs::create_dir_all(&modules_dir)?;
    
    for module in &analysis.modules {
        let module_name = Path::new(&module.path)
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown");
        
        let module_path = modules_dir.join(format!("{}.md", module_name));
        let mut file = fs::File::create(&module_path)?;
        
        writeln!(file, "# {}\n", module_name)?;
        writeln!(file, "**Path:** `{}`\n", module.path)?;
        writeln!(file, "{}\n", module.summary)?;
        
        if !module.exports.is_empty() {
            writeln!(file, "## Exports\n")?;
            
            for export in &module.exports {
                let kind_str = match export.kind {
                    ExportKind::Function => "fn",
                    ExportKind::Class => "class",
                    ExportKind::Type => "type",
                    ExportKind::Const => "const",
                    ExportKind::Enum => "enum",
                    ExportKind::Trait => "trait",
                    ExportKind::Struct => "struct",
                    ExportKind::Module => "mod",
                };
                
                writeln!(file, "### `{}` ({})\n", export.name, kind_str)?;
                
                if let Some(sig) = &export.signature {
                    writeln!(file, "```\n{}\n```\n", sig)?;
                }
                
                if !export.description.is_empty() {
                    writeln!(file, "{}\n", export.description)?;
                }
                
                writeln!(file, "*Line {}*\n", export.line_number)?;
            }
        }
        
        if !module.imports.is_empty() {
            writeln!(file, "## Imports\n")?;
            
            for import in &module.imports {
                let external = if import.is_external { " (external)" } else { "" };
                writeln!(file, "- `{}`{}", import.source, external)?;
                
                for item in &import.items {
                    writeln!(file, "  - {}", item)?;
                }
            }
        }
    }
    
    // Generate gaps.md if there are gaps
    if !crossref.gaps.is_empty() {
        let gaps_path = output_path.join("gaps.md");
        let mut gaps = fs::File::create(&gaps_path)?;
        
        writeln!(gaps, "# Potential Gaps\n")?;
        writeln!(gaps, "Issues identified during analysis:\n")?;
        
        for gap in &crossref.gaps {
            let kind_str = match gap.kind {
                crate::core::analyzer::GapKind::UnusedExport => "âš ï¸ Unused Export",
                crate::core::analyzer::GapKind::MissingDocumentation => "ðŸ“ Missing Docs",
                crate::core::analyzer::GapKind::DeadCode => "ðŸ—‘ï¸ Dead Code",
                crate::core::analyzer::GapKind::UntestedFunction => "ðŸ§ª Untested",
                crate::core::analyzer::GapKind::UndocumentedCommand => "ðŸ’» Undocumented Command",
            };
            
            writeln!(gaps, "### {}\n", kind_str)?;
            writeln!(gaps, "{}", gap.description)?;
            
            if let Some(loc) = &gap.location {
                writeln!(gaps, "\n*Location: {}*\n", loc)?;
            }
        }
    }
    
    Ok(())
}
