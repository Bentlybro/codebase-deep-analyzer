use anyhow::Result;
use std::collections::HashMap;
use std::fs::File;
use std::io::Write;
use std::path::Path;

use crate::core::analyzer::GapKind;
use crate::core::{Analysis, CrossReference};

/// Generate a single CODEBASE.md optimized for LLM consumption
pub fn generate(analysis: &Analysis, crossref: &CrossReference, output_path: &Path) -> Result<()> {
    std::fs::create_dir_all(output_path)?;
    
    let codebase_path = output_path.join("CODEBASE.md");
    let mut f = File::create(&codebase_path)?;

    // Header
    writeln!(f, "# Codebase Documentation\n")?;
    writeln!(f, "_Generated by [CDA](https://github.com/Bentlybro/codebase-deep-analyzer)_\n")?;

    // Architecture Overview (LLM-generated)
    if let Some(overview) = &crossref.architecture_overview {
        writeln!(f, "## Architecture\n")?;
        writeln!(f, "{}\n", overview)?;
    }

    // Quick Stats
    writeln!(f, "## Overview\n")?;
    writeln!(f, "- **Modules:** {}", analysis.modules.len())?;
    writeln!(f, "- **Exports:** {}", analysis.total_exports())?;
    writeln!(f, "- **External Dependencies:** {}", crossref.external_deps.len())?;
    writeln!(f)?;

    // Group modules by directory for structure
    let mut by_dir: HashMap<String, Vec<&crate::core::analyzer::ModuleAnalysis>> = HashMap::new();
    for module in &analysis.modules {
        // Get directory path relative to root
        let dir = Path::new(&module.path)
            .parent()
            .map(|p| {
                // Try to get a reasonable relative path
                let s = p.to_string_lossy();
                // Find common prefixes and strip them
                if let Some(idx) = s.find("/src/") {
                    s[idx..].to_string()
                } else if let Some(idx) = s.find("/lib/") {
                    s[idx..].to_string()
                } else {
                    // Just use last 2-3 components
                    let components: Vec<_> = p.components().collect();
                    let start = if components.len() > 3 { components.len() - 3 } else { 0 };
                    components[start..].iter()
                        .map(|c| c.as_os_str().to_string_lossy())
                        .collect::<Vec<_>>()
                        .join("/")
                }
            })
            .unwrap_or_else(|| "root".to_string());
        by_dir.entry(dir).or_default().push(module);
    }

    // Directory Structure
    writeln!(f, "## Directory Structure\n")?;
    let mut dirs: Vec<_> = by_dir.keys().collect();
    dirs.sort();
    
    for dir in &dirs {
        let modules = &by_dir[*dir];
        let export_count: usize = modules.iter().map(|m| m.exports.len()).sum();
        if export_count > 0 {
            writeln!(f, "- `{}` — {} files, {} exports", dir, modules.len(), export_count)?;
        }
    }
    writeln!(f)?;

    // External Dependencies
    if !crossref.external_deps.is_empty() {
        writeln!(f, "## Dependencies\n")?;
        writeln!(f, "External packages used:\n")?;
        for dep in &crossref.external_deps {
            writeln!(f, "- `{}`", dep)?;
        }
        writeln!(f)?;
    }

    // Key Exports by Directory (the meat of the doc)
    writeln!(f, "## Module Reference\n")?;
    writeln!(f, "Exports organized by directory:\n")?;

    for dir in &dirs {
        let modules = &by_dir[*dir];
        let has_exports = modules.iter().any(|m| !m.exports.is_empty());
        
        if !has_exports {
            continue;
        }

        writeln!(f, "### `{}`\n", dir)?;

        for module in modules {
            if module.exports.is_empty() {
                continue;
            }

            let filename = Path::new(&module.path)
                .file_name()
                .and_then(|s| s.to_str())
                .unwrap_or("unknown");

            writeln!(f, "#### {}\n", filename)?;

            // Compact export list
            for export in &module.exports {
                let sig = export.signature.as_deref().unwrap_or("");
                let desc = if !export.description.is_empty() {
                    format!(" — {}", truncate(&export.description, 80))
                } else {
                    String::new()
                };
                
                if !sig.is_empty() {
                    writeln!(f, "- `{}`{}", truncate(sig, 60), desc)?;
                } else {
                    writeln!(f, "- `{}` ({}){}", export.name, export.kind, desc)?;
                }
            }
            writeln!(f)?;
        }
    }

    // Internal dependency map (simplified)
    writeln!(f, "## Internal Dependencies\n")?;
    writeln!(f, "Key module connections:\n")?;
    
    let mut dep_count: HashMap<&str, usize> = HashMap::new();
    for module in &analysis.modules {
        for import in &module.imports {
            if !import.is_external {
                *dep_count.entry(&import.source).or_default() += 1;
            }
        }
    }
    
    // Show most-imported internal modules
    let mut deps: Vec<_> = dep_count.iter().collect();
    deps.sort_by(|a, b| b.1.cmp(a.1));
    
    for (source, count) in deps.iter().take(20) {
        writeln!(f, "- `{}` — imported {} times", source, count)?;
    }
    writeln!(f)?;

    // Gaps summary (brief)
    if !crossref.gaps.is_empty() {
        writeln!(f, "## Documentation Gaps\n")?;
        
        let missing_docs = crossref.gaps.iter()
            .filter(|g| matches!(g.kind, GapKind::MissingDocumentation))
            .count();
        
        writeln!(f, "- {} exports missing documentation", missing_docs)?;
        writeln!(f)?;
        
        // Show first 10 as examples
        writeln!(f, "Examples:\n")?;
        for gap in crossref.gaps.iter().take(10) {
            if let Some(loc) = &gap.location {
                writeln!(f, "- `{}`", loc)?;
            }
        }
        if crossref.gaps.len() > 10 {
            writeln!(f, "- ... and {} more", crossref.gaps.len() - 10)?;
        }
    }

    writeln!(f, "\n---\n")?;
    writeln!(f, "_This document is optimized for LLM consumption. For raw data, use `--format json`._")?;

    Ok(())
}

fn truncate(s: &str, max: usize) -> &str {
    if s.len() <= max {
        s
    } else {
        let end = s.char_indices()
            .take_while(|(i, _)| *i < max - 3)
            .last()
            .map(|(i, c)| i + c.len_utf8())
            .unwrap_or(0);
        &s[..end]
    }
}
